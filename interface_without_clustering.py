# -*- coding: utf-8 -*-
"""INterface without clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14c3D1eBnkfayiuF0o2FGSur9BQHqsSLS
"""

import pandas as pd
import numpy as np
import streamlit as st
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.svm import SVR
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# Function to calculate AIC
def calculate_aic(n, mse, num_params):
    aic = n * np.log(mse) + 2 * num_params
    return aic

# Load the data
data = pd.read_excel('data_ready_2.xlsx')

# Drop the first 5 columns
data = data.drop(data.columns[[0, 1, 2, 3, 4]], axis=1)

# Set categorical columns
data['Category'] = data['Category'].astype('category')
data['Show_status'] = data['Show_status'].astype('category')
data['Time of the day'] = data['Time of the day'].astype('category')
data['Capacity level'] = data['Capacity level'].astype('category')

# Define features and target variable
features = ['Number of previous performances', 'Show length (minutes']
categorical_features = ['Category', 'Show_status', 'Time of the day', 'Capacity level']

# One-hot encode categorical features
data = pd.get_dummies(data, columns=categorical_features)

# Extend the features list with one-hot encoded columns
one_hot_features = [col for col in data.columns if col.startswith(tuple(categorical_features))]
features.extend(one_hot_features)
target = 'Total seats sold'

# Standardize the numerical variables
scaler = StandardScaler()
data[['Number of previous performances', 'Show length (minutes']] = scaler.fit_transform(data[['Number of previous performances', 'Show length (minutes']])

# Split the data into training and testing sets
X = data[features]
y = data[target]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Function to train and evaluate a model
def train_and_evaluate_model(X_train, X_test, y_train, y_test, model, model_name):
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    mae = mean_absolute_error(y_test, y_pred)
    mse = mean_squared_error(y_test, y_pred)
    rmse = mse ** 0.5
    r2 = r2_score(y_test, y_pred)
    aic = calculate_aic(len(y_test), mse, X_train.shape[1] + 1)
    print(f"{model_name} - MAE: {mae:.2f}, MSE: {mse:.2f}, RMSE: {rmse:.2f}, AIC: {aic:.2f}")
    return model, aic

# Initialize model candidates
model_candidates = [
    ("Linear Regression", LinearRegression()),
    ("Decision Tree Regressor", DecisionTreeRegressor(random_state=42)),
    ("Random Forest Regressor", RandomForestRegressor(random_state=42)),
    ("Gradient Boosting Regressor", GradientBoostingRegressor(random_state=42)),
    ("Support Vector Regressor", SVR())
]

# Train models and select the best one based on AIC
best_model = None
best_aic = np.inf

for model_name, model in model_candidates:
    model, aic = train_and_evaluate_model(X_train, X_test, y_train, y_test, model, model_name)
    if aic < best_aic:
        best_model = model
        best_aic = aic

print(f"Best model: {best_model.__class__.__name__} with AIC: {best_aic:.2f}\n")

# Function to predict ticket sales for a new show
def predict_ticket_sales(new_show, scaler, best_model, features):
    # Convert the new show to a DataFrame
    new_show_df = pd.DataFrame([new_show])

    # Standardize the numerical variables
    new_show_df[['Number of previous performances', 'Show length (minutes']] = scaler.transform(new_show_df[['Number of previous performances', 'Show length (minutes']])

    # One-hot encode the categorical features
    new_show_df = pd.get_dummies(new_show_df, columns=categorical_features)

    # Align the new show DataFrame with the training DataFrame
    new_show_df = new_show_df.reindex(columns=X.columns, fill_value=0)

    # Use the best model to predict ticket sales
    predicted_tickets = best_model.predict(new_show_df[features])[0]

    return int(np.round(predicted_tickets))

# Streamlit interface
st.title("Theater Show Ticket Sales Predictor")

# Input form
with st.form(key='show_form'):
    category = st.selectbox('Category', ['Musical', 'Cabaret', 'Concert', 'Dans', 'Jeugd', 'Muziektheater', 'Specials', 'Toneel'])
    show_length = st.number_input('Show length (minutes)', min_value=0, value=90)
    show_status = st.selectbox('Show status', ['New', 'Returning'])
    time_of_day = st.selectbox('Time of the day', ['Afternoon', 'Evening'])
    num_prev_performances = st.number_input('Number of previous performances', min_value=0, value=0)
    capacity_level = st.selectbox('Capacity level', ['small', 'medium', 'large'])

    submit_button = st.form_submit_button(label='Predict Ticket Sales')

# Prediction
if submit_button:
    new_show = {
        'Category': category,
        'Show length (minutes': show_length,
        'Show_status': show_status,
        'Time of the day': time_of_day,
        'Number of previous performances': num_prev_performances,
        'Capacity level': capacity_level
    }

    predicted_tickets = predict_ticket_sales(new_show, scaler, best_model, features)
    st.write(f"Predicted tickets sold: {predicted_tickets}")